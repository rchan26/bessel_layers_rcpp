# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Bessel Layer simulation
#'
#' Simulates a Bessel layer l for a given sequence a
#'
#' @param x start value of Brownian bridge
#' @param y end value of Brownian bridge
#' @param s start time of Brownian bridge
#' @param t end time of Brownian bridge
#' @param a vector/sequence of numbers
#'
#' @examples
#' bessel_layer_simulation(x = 0, y = 0, s = 0, t = 1, a = seq(0.1, 0.5, 0.1))
#'
#' @export
bessel_layer_simulation <- function(x, y, s, t, a) {
    .Call(`_layeredBB_bessel_layer_simulation`, x, y, s, t, a)
}

#' Brownian Bridge minimum point sampler
#'
#' This function simulates a minimum point of a Brownian bridge
#'
#' @param x start value of Brownian bridge
#' @param y end value of Brownian bridge
#' @param s start value of Brownian bridge
#' @param t end value of Brownian bridge
#' @param low_bound Lower bound of minimum point (low_bound < up_bound <= min(x,y))
#' @param up_bound Upper bound of minimum point (low_bound < up_bound <= min(x,y))
#'
#' @return vector: the simulated minimum, 'min', and time where minimum occurs, 'tau'
#'
#' @examples
#' # simulate a minimum between 0 and 1 of a Brownian bridge starting at 0 and ending at 0 in time [0,1]
#' min_sampler(x=0, y=0, s=0, t=1, low_bound = -1, up_bound = 0)
#'
#' @export
min_sampler <- function(x, y, s, t, low_bound, up_bound) {
    .Call(`_layeredBB_min_sampler`, x, y, s, t, low_bound, up_bound)
}

#' Bessel Bridge point sampler given minimum
#'
#' This function simulates a point of a Bessel bridge at time q, given minimum occurs at time tuu
#'
#' @param x start value of Bessel bridge
#' @param y end value of Bessel bridge
#' @param s start value of Bessel bridge
#' @param t end value of Bessel bridge
#' @param min minumum point
#' @param tau time of minimum point
#' @param q time of simulation
#'
#' @return simulated point of the Bessel bridge at time q
#'
#' @examples
#' # simulating a point at q=0.2 for a Bessel bridge starting at 0 and ending at 0 in time [0,1] given minimum is at -0.4 at time 0.6
#' min_Bessel_bridge_sampler(x = 0, y = 0, s = 0, t = 1, min = -0.4, tau = 0.6, q = 0.2)
#'
#' @export
min_Bessel_bridge_sampler <- function(x, y, s, t, min, tau, q) {
    .Call(`_layeredBB_min_Bessel_bridge_sampler`, x, y, s, t, min, tau, q)
}

#' Bessel Bridge path sampler given minimum
#'
#' This function simulates a path of a Bessel bridge at given times, given minimum occurs at time tau
#'
#' @param x start value of Bessel bridge
#' @param y end value of Bessel bridge
#' @param s start value of Bessel bridge
#' @param t end value of Bessel bridge
#' @param min minumum point
#' @param tau time of minimum point
#' @param times vector of real numbers to simulate Bessel bridge
#'
#' @return matrix of the simulated Bessel bridge path, first row is points X, second row are corresponding times
#'
#' @examples
#' # simulating a path at times=c(0.2, 0.4, 0.8) for a Bessel bridge starting at 0 and ending at 0 in time [0,1] given minimum is at -0.4 at time 0.6
#' min_Bessel_bridge_path_sampler(x = 0, y = 0, s = 0, t = 1, min = -0.4, tau = 0.6, times = c(0.2, 0.4, 0.8))
#'
#' @export
min_Bessel_bridge_path_sampler <- function(x, y, s, t, min, tau, times) {
    .Call(`_layeredBB_min_Bessel_bridge_path_sampler`, x, y, s, t, min, tau, times)
}

#' Brownian Bridge maximum point sampler
#'
#' This function simulates a maximum point of a Brownian bridge
#'
#' @param x start value of Brownian bridge
#' @param y end value of Brownian bridge
#' @param s start value of Brownian bridge
#' @param t end value of Brownian bridge
#' @param low_bound Lower bound of maximum point (max(x,y) <= low_bound < up_bound)
#' @param up_bound Upper bound of maximum point (max(x,y) <= low_bound < up_bound)
#'
#' @return vector: the simulated maximum, 'max', and time where maximum occurs, 'tau'
#'
#' @examples
#' # simulate a maximum between 0 and 1 of a Brownian bridge starting at 0 and ending at 0 in time [0,1]
#' max_sampler(x=0, y=0, s=0, t=1, low_bound = 0, up_bound = 1)
#'
#' @export
max_sampler <- function(x, y, s, t, low_bound, up_bound) {
    .Call(`_layeredBB_max_sampler`, x, y, s, t, low_bound, up_bound)
}

#' Bessel Bridge point sampler given maximum
#'
#' This function simulates a point of a Bessel bridge at time q, given maximum occurs at time tuu
#'
#' @param x start value of Bessel bridge
#' @param y end value of Bessel bridge
#' @param s start value of Bessel bridge
#' @param t end value of Bessel bridge
#' @param max maxumum point 
#' @param tau time of maximum point
#' @param q time of simulation
#' 
#' @return simulated point of the Bessel bridge at time q
#'
#' @examples
#' # simulating a point at q=0.2 for a Bessel bridge starting at 0 and ending at 0 in time [0,1] given maximum is at 0.4 at time 0.6
#' max_Bessel_bridge_sampler(x = 0, y = 0, s = 0, t = 1, max = 0.4, tau = 0.6, q = 0.2)
#'
#' @export
max_Bessel_bridge_sampler <- function(x, y, s, t, max, tau, q) {
    .Call(`_layeredBB_max_Bessel_bridge_sampler`, x, y, s, t, max, tau, q)
}

#' Bessel Bridge path sampler given maximum
#'
#' This function simulates a path of a Bessel bridge at given times, given maximum occurs at time tuu
#'
#' @param x start value of Bessel bridge
#' @param y end value of Bessel bridge
#' @param s start value of Bessel bridge
#' @param t end value of Bessel bridge
#' @param max maxumum point 
#' @param tau time of maximum point
#' @param times vector of real numbers to simulate Bessel bridge
#' 
#' @return matrix of the simulated Bessel bridge path, first row is points X, second row are corresponding times
#'
#' @examples
#' # simulating a path at times=c(0.2, 0.4, 0.8) for a Bessel bridge starting at 0 and ending at 0 in time [0,1] given maximum is at 0.4 at time 0.6
#' max_Bessel_bridge_path_sampler(x = 0, y = 0, s = 0, t = 1, max = 0.4, tau = 0.6, times = c(0.2, 0.4, 0.8))
#'
#' @export
max_Bessel_bridge_path_sampler <- function(x, y, s, t, max, tau, times) {
    .Call(`_layeredBB_max_Bessel_bridge_path_sampler`, x, y, s, t, max, tau, times)
}

#' Sigma_Bar
#'
#' This function evaluates the sigma_bar function used to simulate Bessel Layers in the infinite sums
#'
#' @param j real value
#' @param x start value of Brownian bridge
#' @param y end value of Brownian bridge
#' @param s start value of Brownian bridge
#' @param t end value of Brownian bridge
#' @param l lower bound of Brownian bridge
#' @param v upper bound of Brownian bridge
#' 
#' @return real value: sigma_bar evaluated at point j
#'
#' @examples
#' sigma_bar(j = 1, x = 0, y = 0, s = 0, t = 1, l = -2, v = 1)
#'
#' @export
sigma_bar <- function(j, x, y, s, t, l, v) {
    .Call(`_layeredBB_sigma_bar`, j, x, y, s, t, l, v)
}

#' Sigma
#'
#' This function evaluates the sigma function used to simulate Bessel Layers in the infinite sums
#'
#' @param j real value
#' @param x start value of Brownian bridge
#' @param y end value of Brownian bridge
#' @param s start value of Brownian bridge
#' @param t end value of Brownian bridge
#' @param l lower bound of Brownian bridge
#' @param v upper bound of Brownian bridge
#' 
#' @return real value: sigma evaluated at point j
#'
#' @examples
#' sigma(j = 1, x = 0, y = 0, s = 0, t = 1, l = -2, v = 1)
#'
#' @export
sigma <- function(j, x, y, s, t, l, v) {
    .Call(`_layeredBB_sigma`, j, x, y, s, t, l, v)
}

#' Phi_Bar
#'
#' This function evaluates the phi_bar function used to simulate Bessel Layers in the infinite sums
#'
#' @param j real value
#' @param x start value of Brownian bridge
#' @param y end value of Brownian bridge
#' @param s start value of Brownian bridge
#' @param t end value of Brownian bridge
#' @param l lower bound of Brownian bridge
#' @param v upper bound of Brownian bridge
#' 
#' @return real value: phi_bar evaluated at point j
#'
#' @examples
#' phi_bar(j = 1, x = 0, y = 0, s = 0, t = 1, l = -2, v = 1)
#'
#' @export
phi_bar <- function(j, x, y, s, t, l, v) {
    .Call(`_layeredBB_phi_bar`, j, x, y, s, t, l, v)
}

#' Phi
#'
#' This function evaluates the phi function used to simulate Bessel Layers in the infinite sums
#'
#' @param j real value
#' @param x start value of Brownian bridge
#' @param y end value of Brownian bridge
#' @param s start value of Brownian bridge
#' @param t end value of Brownian bridge
#' @param l lower bound of Brownian bridge
#' @param v upper bound of Brownian bridge
#' 
#' @return real value: phi evaluated at point j
#'
#' @examples
#' phi(j = 1, x = 0, y = 0, s = 0, t = 1, l = -2, v = 1)
#' 
#' @export
phi <- function(j, x, y, s, t, l, v) {
    .Call(`_layeredBB_phi`, j, x, y, s, t, l, v)
}

#' Psi
#'
#' This function evaluates the psi function used to simulate Bessel Layers in the infinite sums
#'
#' @param j real value
#' @param x start value of Brownian bridge
#' @param y end value of Brownian bridge
#' @param s start value of Brownian bridge
#' @param t end value of Brownian bridge
#' @param min minimum of Brownian bridge
#' @param v upper bound of Brownian bridge
#' 
#' @return real value: psi evaluated at point j
#'
#' @examples
#' psi(j = 1, x = 0, y = 0, s = 0, t = 1, min = -2, v = 1)
#' 
#' @export
psi <- function(j, x, y, s, t, min, v) {
    .Call(`_layeredBB_psi`, j, x, y, s, t, min, v)
}

#' Chi
#'
#' This function evaluates the psi function used to simulate Bessel Layers in the infinite sums
#'
#' @param j real value
#' @param x start value of Brownian bridge
#' @param y end value of Brownian bridge
#' @param s start value of Brownian bridge
#' @param t end value of Brownian bridge
#' @param min minimum of Brownian bridge
#' @param v upper bound of Brownian bridge
#' 
#' @return real value: chi evaluated at point j
#'
#' @examples
#' chi(j = 1, x = 0, y = 0, s = 0, t = 1, min = -2, v = 1)
#'
#' @export
chi <- function(j, x, y, s, t, min, v) {
    .Call(`_layeredBB_chi`, j, x, y, s, t, min, v)
}

#' Calculate interval: [S^{gamma}_{2k+1}, S^{gamma}_{2k}]
#'
#' This function calculates the interval [S^{gamma}_{2k+1}, S^{gamma}_{2k}] for given k
#'
#' @param k integer value
#' @param x start value of Brownian bridge
#' @param y end value of Brownian bridge
#' @param s start value of Brownian bridge
#' @param t end value of Brownian bridge
#' @param l lower bound of Brownian bridge
#' @param v upper bound of Brownian bridge
#'
#' @return vector of two values, S^{gamma}_{2k+1} and S^{gamma}_{2k}
#'
#' @examples
#' calc_SgammaK_intervals(k = 1, x = 0, y = 0, s = 0, t = 1, l = -2, v = 1)
#'
#' @export
calc_SgammaK_intervals <- function(k, x, y, s, t, l, v) {
    .Call(`_layeredBB_calc_SgammaK_intervals`, k, x, y, s, t, l, v)
}

#' Calculate interval: [S^{delta,1}_{2k+1}, S^{delta,1}_{2k}]
#'
#' This function calculates the interval [S^{delta,1}_{2k+1}, S^{delta, 1}_{2k}] (case where min(x,y) > min)
#'
#' @param k integer value
#' @param x start value of Brownian bridge
#' @param y end value of Brownian bridge
#' @param s start value of Brownian bridge
#' @param t end value of Brownian bridge
#' @param min minimum of Brownian bridge
#' @param v upper bound of Brownian bridge
#'
#' @return vector of two values, S^{delta,1}_{2k+1} and S^{delta,1}_{2k}
#'
#' @examples
#' calc_SdeltaK_1_intervals(k = 1, x = 0, y = 0, s = 0, t = 1, min = -2, v = 1)
#'
#' @export
calc_SdeltaK_1_intervals <- function(k, x, y, s, t, min, v) {
    .Call(`_layeredBB_calc_SdeltaK_1_intervals`, k, x, y, s, t, min, v)
}

#' Calculate interval: [S^{delta,2}_{2k+1}, S^{delta,2}_{2k}]
#'
#' This function calculates the interval [S^{delta,2}_{2k+1}, S^{delta, 2}_{2k}] (case where min(x,y) == min)
#'
#' @param k integer value
#' @param x start value of Brownian bridge
#' @param y end value of Brownian bridge
#' @param s start value of Brownian bridge
#' @param t end value of Brownian bridge
#' @param min minimum of Brownian bridge
#' @param v upper bound of Brownian bridge
#'
#' @return vector of two values, S^{delta,2}_{2k+1} and S^{delta,2}_{2k}
#'
#' @examples
#' K = ceiling(sqrt((1)+(abs(1-(-2))*abs(1-(-2))))/(2*abs(1-(-2))))
#' calc_SdeltaK_2_intervals(k = K, x = -2, y = 0, s = 0, t = 0, min = -2, v = 1)
#'
#' @export
calc_SdeltaK_2_intervals <- function(k, x, y, s, t, min, v) {
    .Call(`_layeredBB_calc_SdeltaK_2_intervals`, k, x, y, s, t, min, v)
}

#' Calculate interval: [S^{delta}_{2k+1}, S^{delta}_{2k}]
#'
#' This function calculates the interval [S^{delta}_{2k+1}, S^{delta}_{2k}] (case where min(x,y) > min or where min(x,y) == min)
#'
#' @param k integer value
#' @param x start value of Brownian bridge
#' @param y end value of Brownian bridge
#' @param s start value of Brownian bridge
#' @param t end value of Brownian bridge
#' @param min minimum of Brownian bridge
#' @param v upper bound of Brownian bridge
#'
#' @return vector of two values, S^{delta}_{2k+1} and S^{delta}_{2k}
#'
#' @examples
#' # case where min(x,y ) > min
#' calc_SdeltaK_1_intervals(k = 1, x = 0, y = 0, s = 0, t = 1, min = -2, v = 1)
#'
#' # case where min(x,y) == min
#' K = ceiling(sqrt((1)+(abs(1-(-2))*abs(1-(-2))))/(2*abs(1-(-2))))
#' calc_SdeltaK_intervals(k = K, x = -2, y = 0, s = 0, t = 0, min = -2, v = 1)
#'
#' @export
calc_SdeltaK_intervals <- function(k, x, y, s, t, min, v) {
    .Call(`_layeredBB_calc_SdeltaK_intervals`, k, x, y, s, t, min, v)
}

#' Find product of a vector
#'
#' This function product of the elements of a numerical vector
#'
#' @param vect numerical vector
#'
#' @return product of element in vector given
#'
#' @examples
#' # returns 120
#' find_max(c(1,2,3,4,5)) 
#'
#' @export
product_vector_elements <- function(vect) {
    .Call(`_layeredBB_product_vector_elements`, vect)
}

#' Gamma coin flipper
#'
#' Flips 'Gamma coin'; uses the Cauchy sequence S^{gamma}_{k} to 
#' determine whether or not the Brownian bridge starting at x, ending at y, between [s,t]
#' remains in interval [l,v]
#'
#' @param x start value of Brownian bridge
#' @param y end value of Brownian bridge
#' @param s start value of Brownian bridge
#' @param t end value of Brownian bridge
#' @param l lower bound of Brownian bridge
#' @param v upper bound of Brownian bridge
#' @param k integer value
#'
#' @examples
#' gamma_coin(x = 0, y = 0, s = 0, t = 1, l = -0.5, v = 0.5, k = 1)
#'
#' @return boolean value: if T, accept probability that Brownian bridge remains in [l,v], otherwise reject
#'
#' @export
gamma_coin <- function(x, y, s, t, l, v, k) {
    .Call(`_layeredBB_gamma_coin`, x, y, s, t, l, v, k)
}

#' Gamma coin flipper for intervals
#'
#' Flips 'Gamma coin' for intervals; takes the product of the Cauchy sequence S^{gamma}_{k} to 
#' determine whether or not the Brownian bridge remains in the interval [l,v]
#' Vectors x, y, s, t should all be the same length, L, where for i = 1, ..., L, the Brownian Bridge skeleton 
#' we have is broken up so that x[i] goes to y[i] between s[i] and t[i] - see example
#'
#' @param x vector of values
#' @param y vector of values
#' @param s vector of values
#' @param t vector of values
#' @param l lower bound of Brownian bridge
#' @param v upper bound of Brownian bridge
#' @param k integer value
#'
#' @examples
#' # setting up vectors
#' x_vect <- c(); y_vect <- c(); s_vect <- c(); t_vect <- c()
#' brownian_bridge <- matrix(c(0, 0, -0.2, 0.4, 1, 1), ncol = 3, nrow = 2)
#' for (i in 1:(ncol(brownian_bridge)-1)) {
#'   x_vect[i] <- brownian_bridge[1,i]
#'   y_vect[i] <- brownian_bridge[1,(i+1)]
#'   s_vect[i] <- brownian_bridge[2,i]
#'   t_vect[i] <- brownian_bridge[2,(i+1)]
#' }
#' 
#' # flip gamma coin whether or not Brownian bridge remains in [-0.5, 1.5]
#' gamma_coin_intervals(x = x_vect, y = y_vect, s = s_vect, t = t_vect, l = -0.5, v = 1.5, k = 1)
#'
#' @return boolean value: if T, accept probability that Brownian bridge remains in [l,v], otherwise reject
#'
#' @export
gamma_coin_intervals <- function(x, y, s, t, l, v, k) {
    .Call(`_layeredBB_gamma_coin_intervals`, x, y, s, t, l, v, k)
}

#' Delta coin flipper
#'
#' Flips 'Delta coin'; uses the Cauchy sequence S^{delta}_{k} to 
#' determine whether or not the Brownian bridge with minimum, min, 
#' starting at x, ending at y, between [s,t] remains in interval [l,v]
#'
#' @param x start value of Brownian bridge
#' @param y end value of Brownian bridge
#' @param s start value of Brownian bridge
#' @param t end value of Brownian bridge
#' @param min minimum of Brownian bridge
#' @param v upper bound of Brownian bridge
#' @param k integer value
#'
#' @examples
#'
#' @return boolean value: if T, accept probability that Brownian bridge with minimum, min, remains in [l,v], otherwise reject
#'
#' @export
delta_coin <- function(x, y, s, t, min, v, k) {
    .Call(`_layeredBB_delta_coin`, x, y, s, t, min, v, k)
}

#' Delta coin flipper for intervals
#'
#' Flips 'Delta coin' for intervals; takes the product of the Cauchy sequence S^{delta}_{k} to 
#' determine whether or not the Brownian bridge with minimum, min, remains in the interval [l,v]
#' Vectors x, y, s, t should all be the same length, L, where for i = 1, ..., L, the Brownian Bridge skeleton 
#' we have is broken up so that x[i] goes to y[i] between s[i] and t[i] - see example
#'
#' @param x vector of values
#' @param y vector of values
#' @param s vector of values
#' @param t vector of values
#' @param min minimum of Brownian bridge
#' @param v upper bound of Brownian bridge
#' @param k integer value
#'
#' @examples
#' # setting up vectors
#' x_vect <- c(); y_vect <- c(); s_vect <- c(); t_vect <- c()
#' brownian_bridge <- matrix(c(0, 0, -0.2, 0.4, 1, 1), ncol = 3, nrow = 2)
#' for (i in 1:(ncol(brownian_bridge)-1)) {
#'   x_vect[i] <- brownian_bridge[1,i]
#'   y_vect[i] <- brownian_bridge[1,(i+1)]
#'   s_vect[i] <- brownian_bridge[2,i]
#'   t_vect[i] <- brownian_bridge[2,(i+1)]
#' }
#' 
#' # flip delta coin whether or not Brownian bridge remains in [-0.2, 1.5]
#' delta_coin_intervals(x = x_vect, y = y_vect, s = s_vect, t = t_vect, min = -0.2, v = 1.5, k = 1)
#'
#' @return boolean value: if T, accept probability that Brownian bridge with minimum, min, remains in [l,v], otherwise reject
#'
#' @export
delta_coin_intervals <- function(x, y, s, t, min, v, k) {
    .Call(`_layeredBB_delta_coin_intervals`, x, y, s, t, min, v, k)
}

#' Inverse Gaussian Sampler
#'
#' This function returns 1 sample from an Inverse Gaussian distribution with mean mu and shape lambda
#'
#' @param mu mean
#' @param lambda shape
#' 
#' @return real value: simulated point from Inverse Gaussian distribution with mean mu and shape lambda
#'
#' @examples
#' curve(statmod::dinvgauss(x, mean = 1, shape = 1), 0, 4)
#' samples <- sapply(1:10000, function(i) inv_gauss_sampler(mu = 1, lambda =1))
#' lines(density(x = samples, adjust = 0.5), col = 'blue')
#'
#' @export
inv_gauss_sampler <- function(mu, lambda) {
    .Call(`_layeredBB_inv_gauss_sampler`, mu, lambda)
}

#' Find maximum of vector
#'
#' This function finds the maximum value of a numerical vector
#'
#' @param vect numerical vector
#'
#' @return maximum of vector given
#'
#' @examples
#' # returns 0.8
#' find_max(c(-0.4, 0.23, -0.4321, 0.6, 0.3, 0.8, 0.54)) 
#'
#' @export
find_max <- function(vect) {
    .Call(`_layeredBB_find_max`, vect)
}

#' Find minimum of vector
#'
#' This function finds the minimum value of a numerical vector
#'
#' @param vect numerical vector
#'
#' @return minimum of vector given
#' 
#' @examples
#' # returns -0.4321
#' find_min(c(-0.4, 0.23, -0.4321, 0.6, 0.3, 0.8, 0.54)) 
#'
#' @export
find_min <- function(vect) {
    .Call(`_layeredBB_find_min`, vect)
}

#' Layered Brownian Bridge sampler
#'
#' This function simulates a layered Brownian Bridge given a Bessel layer, at given times
#'
#' @param x start value of Brownian bridge
#' @param y end value of Brownian bridge
#' @param s start value of Brownian bridge
#' @param t end value of Brownian bridge
#' @param a vector/sequence of numbers
#' @param l integer number denoting Bessel layer, i.e. Brownian bridge is contained in [min(x,y)-a[l], max(x,y)+a[l]]
#' @param times vector of real numbers to simulate Bessel bridge
#' 
#' @return matrix of the simulated layered Brownian bridge path, first row is points X, second row are corresponding times
#'
#' @examples
#' # simulate Bessel layer
#' bes_layer <- bessel_layer_simulation(x = 0, y = 0, s = 0, t = 1, a = seq(0.1, 1.0, 0.1))
#' # simulate layered Brownian bridge
#' layered_brownian_bridge(x = 0, y = 0, s = 0, t = 1, a = bes_layer$a, l = bes_layer$l, times = seq(0.2, 0.8, 0.2))
#'
#' @export
layered_brownian_bridge <- function(x, y, s, t, a, l, times) {
    .Call(`_layeredBB_layered_brownian_bridge`, x, y, s, t, a, l, times)
}

